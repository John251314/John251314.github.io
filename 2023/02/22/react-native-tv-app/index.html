


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>  React-Native AndroidTV应用开发实践 |    Jihui.</title>
  <meta name="description" content="欢迎来到继辉的个人技术博客.">
  <!-- 标签页图标 -->
  
  <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
  

  <!-- 图标库 -->
  <link href="https://cdn.jsdelivr.net/npm/remixicon@2.2.0/fonts/remixicon.css" rel="stylesheet">
  <!-- 动画库 -->
  
  <link rel="stylesheet" href="/css/animate.css"/>
  
  <!-- css文件 -->
  
<link rel="stylesheet" href="/css/white.css">

  <!-- 代码高亮 -->
  
    
      
<link rel="stylesheet" href="/css/github.css">

    
  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>

<div class="menu-outer">
    <div class="menu-inner">
      <div class="menu-site-name  animate__animated  animate__fadeInUp">
        <a href="/">
          Jihui.
        </a>
        
      </div>
      <div class="menu-group">
        <ul class="menu-ul">
        
          <a href="/" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              HOME
            </li>
          </a>
        
          <a href="/archives" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              BLOG
            </li>
          </a>
        
        
        
          <li class="menu-li animate__animated  animate__fadeInUp" id="mobile-menu">
            <i class="ri-menu-line"></i>
          </li>
        
        </ul>

      </div>

    </div>
</div>
<div id="mobile-main" class="animate__animated  animate__fadeIn">
  <div class="mobile-menu-inner">
    <div class="mobile-menu-site-name animate__animated  animate__fadeInUp">
      <a href="/">
        Jihui.
      </a>
    </div>
    <div class="mobile-menu-group" id="mobile-close">
      <i class="ri-close-line"></i>
    </div>

  </div>

  <div class="mobile-menu-div">
  
    <a href="/" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>HOME</span>
      </div>
    </a>
  
    <a href="/archives" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>BLOG</span>
      </div>
    </a>
  
  
  </div>


</div>

<div class="body-outer">
  <div class="body-inner">
    
<article class="post-inner">
  <div class="post-content-outer">
    <div class="post-intro">
      <div class="post-title animate__animated  animate__fadeInUp">react-native AndroidTV应用开发实践</div>
      <div class="meta-intro animate__animated  animate__fadeInUp">2月 22 2023</div>
      <!-- 
        <div class="post-cover"><span class="lazyload-img-span"><img data-src="/images/mi-tv-banner.webp" class="post-cover-img"></span></div>
       -->
    </div>
    <div class="post-content-inner">
      <div class="post-content-inner-space">

      </div>
      <div class="post-content-main animate__animated  animate__fadeInUp">
        <!-- top型目录 -->
        
        <p>大约两年前，我们团队开始了基于快消行业数据分析产品线“舟易”的开发工作，随着业务的发展，除了移动端app和pc端web的开发，基于AndroidOS的大屏应用开发也被急迫的推上了开发的进程。</p>
<h2 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h2><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>如果单从技术角度讲，选用<a target="_blank" rel="noopener" href="https://developer.android.google.cn/tv?hl=zh-cn">AndroidTV</a>原生的开发方式，可能是最佳技术的技术选型，除了Android系统额外处理，还有众多的官方库的支撑；当时开发急迫，加上react大前端技术栈和人效和可维护性的考虑下，团队优先考虑基于<a target="_blank" rel="noopener" href="https://reactnative.dev/docs/building-for-tv">react-native-tv-os</a>的RN开发的技术解决方案，并在一周左右完成了第一版的开发上线，并在后续完成多轮迭代和性能优化情况下，现在看仍有不错的性能表现；</p>
<img src='/images/android-tv.webp' style='border-radius: 16px'/>


<h3 id="技术演进"><a href="#技术演进" class="headerlink" title="技术演进"></a>技术演进</h3><p>“舟易大屏”的开发大概分为三个阶段：<br>    1. 第一阶段主要是以webvie作为载体，主要是以数据指标的呈现为主，用户交互要求不高，但是面临很多分为，如加载性能问题，兼容性问题，从用户体验角度来讲，几乎是严重的灾难；<br>    2. 第二个阶段主要是以socket技术为载体，通过app操控大屏完成用户交互，并使用react-native逐步完成webvie的重写，在加载性能和用户体验上带来非常大的提升；<br>    3. 第三个阶段，主要是完成大屏遥控技术方案，同时支持app投射和遥控器操控两种交互方式，支持大屏数据模块的可配置化等功能；</p>
<h2 id="工程化配置"><a href="#工程化配置" class="headerlink" title="工程化配置"></a>工程化配置</h2><h3 id="Android配置"><a href="#Android配置" class="headerlink" title="Android配置"></a>Android配置</h3><p>Android端，可以参考<a target="_blank" rel="noopener" href="https://developer.android.google.cn/training/tv/start/start?hl=zh-cn">开发者网站</a>中的描述，进行配置</p>
<p>声明 TV Activity<br>目标平台为 TV 设备的应用必须在其清单中声明 TV 启动器 Activity。它使用 CATEGORY_LEANBACK_LAUNCHER intent 过滤器来执行此操作。此过滤器可将您的应用标识为支持 TV 平台，并让 Google Play 将其识别为 TV 应用。当用户在其 TV 主屏幕上选择您的应用时，此 intent 可确定要启动的 Activity。</p>
<p>以下代码段展示了如何在清单中添加此 intent 过滤器：</p>
<pre><code class="xml">    &lt;application
      android:banner=&quot;@drawable/banner&quot; &gt;
      ...
      &lt;activity
        android:name=&quot;com.example.android.MainActivity&quot;
        android:label=&quot;@string/app_name&quot; &gt;

        &lt;intent-filter&gt;
          &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
          &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
        &lt;/intent-filter&gt;
      &lt;/activity&gt;

      &lt;activity
        android:name=&quot;com.example.android.TvActivity&quot;
        android:label=&quot;@string/app_name&quot;
        android:theme=&quot;@style/Theme.Leanback&quot;&gt;

        &lt;intent-filter&gt;
          &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
          &lt;category android:name=&quot;android.intent.category.LEANBACK_LAUNCHER&quot; /&gt;
        &lt;/intent-filter&gt;

      &lt;/activity&gt;
    &lt;/application&gt;
</code></pre>
<p>声明 Leanback 支持<br>声明您的应用使用 Android TV 所要求的 Leanback 界面。如果您要开发一款在移动设备（手机、穿戴式设备、平板电脑等）以及 Android TV 上都可运行的应用，请将 required 属性值设为 false。如果您将 required 属性值设为 true，您的应用将只能在使用 Leanback 界面的设备上运行。</p>
<pre><code class="xml">    &lt;manifest&gt;
        &lt;uses-feature android:name=&quot;android.software.leanback&quot;
            android:required=&quot;false&quot; /&gt;
        ...
    &lt;/manifest&gt;
</code></pre>
<p>将触摸屏声明为非必备条件<br>目标平台为 TV 设备的应用不依赖于触摸屏进行输入。为明确这一点，您的 TV 应用的清单必须声明 android.hardware.touchscreen 功能为非必备功能。此设置会将您的应用标识为能够在 TV 设备上工作，这也是您的应用在 Google Play 中被视为 TV 应用的必要条件。以下代码示例展示了如何添加此清单声明：</p>
<pre><code class="xml">    &lt;manifest&gt;
        &lt;uses-feature android:name=&quot;android.hardware.touchscreen&quot;
                  android:required=&quot;false&quot; /&gt;
        ...
    &lt;/manifest&gt;
</code></pre>
<h3 id="RN配置"><a href="#RN配置" class="headerlink" title="RN配置"></a>RN配置</h3><p><code>package.json</code>中使用<code>react-native-tvos</code>库代替原来的<code>react-native</code>库</p>
<pre><code>&quot;react-native&quot;: &quot;npm:react-native-tvos@0.68.0-0&quot;
</code></pre>
<p><code>build.grade</code>中<code>rn</code>版本和上述版本保持一致；</p>
<pre><code>implementation &quot;com.facebook.react:react-native:0.68.0-0!!&quot;  // From node_modules
</code></pre>
<h2 id="遥控事件分发"><a href="#遥控事件分发" class="headerlink" title="遥控事件分发"></a>遥控事件分发</h2><h3 id="事件分发逻辑"><a href="#事件分发逻辑" class="headerlink" title="事件分发逻辑"></a>事件分发逻辑</h3><p><a target="_blank" rel="noopener" href="https://reactnative.dev/docs/building-for-tv">react-native-tv-os</a>原本是基于AppleOS的RN跨平台库，本身基于react-native处理了焦点和遥控事件分发的逻辑，有热心网友在Android原生通过<code>ViewGroup.dispatchEvent</code>和<code>ViewGroup.onFocusChange</code>事件，向react层发送消息，并在react层通过<code>TVEventHandler</code>完成事件的分发；故，在业务层，我们通过监听<code>TVEventHandler</code>完成相关业务处理即可。</p>
<blockquote>
<p>tips：关于元素焦点底层实现非本文讲的重点，可自行百度焦点原理以及指定下个焦点的实现</p>
</blockquote>
<hr>
<p>我们在在rn层使用<code>useTVEventHandler</code>观察原生层发送的事件, 可以得出结论：<br>    1. 依次会收到前一个View失焦，后一个View聚焦，并额外收到一个操作事件，如<code>left</code>、<code>right</code>、<code>up</code>、<code>down</code>、<code>menu</code>、<code>select</code>等；<br>    2. tag和target相同，即为当前焦点元素的id，与<code>findNodeHandle</code>拿到的id相同；<br>    3. 每次焦点切换，总会收到相同<code>tag</code>的两个事件，在非焦点切换时，执行操作，会只收到一个操作事件；</p>
<pre><code class="tsx">export type TVEvent = &#123;
    eventType: TVEventType;
    eventKeyAction: number;
    tag: number;
    target: number;
&#125;;

useTVEventHandler((event: TVEvent) =&gt; &#123;
    console.log(event);
&#125;);

// 通过遥控器，切换焦点时，发送的事件
LOG  &#123;&quot;dispatchConfig&quot;: &#123;&#125;, &quot;eventKeyAction&quot;: -1, &quot;eventType&quot;: &quot;blur&quot;, &quot;tag&quot;: 123, &quot;target&quot;: 123&#125;
LOG  &#123;&quot;dispatchConfig&quot;: &#123;&#125;, &quot;eventKeyAction&quot;: -1, &quot;eventType&quot;: &quot;focus&quot;, &quot;tag&quot;: 169, &quot;target&quot;: 169&#125;
LOG  &#123;&quot;dispatchConfig&quot;: &#123;&#125;, &quot;eventKeyAction&quot;: 1, &quot;eventType&quot;: &quot;right&quot;, &quot;tag&quot;: 169, &quot;target&quot;: 169&#125;
</code></pre>
<p>综上，我们只需要处理焦点元素最后一次事件即可，并把该事件分发给对应的组件，由组件独自完成自己的业务逻辑即可；为了解耦，我们把事件分发逻辑抽象为两层，<code>focuseable</code>和<code>app</code>，即优先发送给当前聚焦组件，如果不响应则分发给app组件；当然如果需要也可以分为三层，如<code>focuseable</code>-&gt;<code>page</code>-&gt;<code>app</code>依次传递。</p>
<h3 id="组件封装"><a href="#组件封装" class="headerlink" title="组件封装"></a>组件封装</h3><p>事件分发逻辑，分别封装<code>useFocusableEventHandler</code>和<code>useAppEventHandler</code>用来注册和分发对应的遥控事件</p>
<pre><code class="tsx">import &#123; RefObject, useEffect, useRef &#125; from &#39;react&#39;;
// @ts-ignore
import &#123; View, useTVEventHandler, findNodeHandle &#125; from &#39;react-native&#39;;

// Native层发送的事件，详见com.facebook.react.modules.core.ReactAndroidHWInputDeviceHelper
export type TVEventType =
    | &#39;select&#39;
    | &#39;playPause&#39;
    | &#39;play&#39;
    | &#39;pause&#39;
    | &#39;stop&#39;
    | &#39;previous&#39;
    | &#39;next&#39;
    | &#39;rewind&#39;
    | &#39;fastForward&#39;
    | &#39;up&#39;
    | &#39;right&#39;
    | &#39;down&#39;
    | &#39;left&#39;
    | &#39;info&#39;
    | &#39;menu&#39;
    | &#39;longSelect&#39;;

export type TVEvent = &#123;
    eventType: TVEventType;
    eventKeyAction: number;
    tag: number;
    target: number;
&#125;;

export type TVEventCallbackObj = &#123;
    [key in TVEventType]?: (event: TVEvent) =&gt; void;
&#125;;

const eventMap = new Map&lt;number, TVEventCallbackObj&gt;();

//! 真机运行较慢，真机运行速度比模拟器慢，此处参数慎改
const duration = __DEV__ ? 2000 : 1000;

export const useAppEventHandler = (uncatchEventHandler: (event: TVEvent) =&gt; void) =&gt; &#123;
    const timeRef = useRef(0);
    const lastTagRef = useRef(0);

    useTVEventHandler((event: TVEvent) =&gt; &#123;
        console.log(event);
        const now = Date.now();
        // 如果当前事件和上次时间的响应元素tag一致，且在duration内，则直接废弃该事件
        if (event.tag === lastTagRef.current &amp;&amp; now - timeRef.current &lt; duration) &#123;
            return;
        &#125;
        // 记录下当前事件响应的tag和时间
        timeRef.current = now;
        lastTagRef.current = event.tag;
        // 如果当前tag对应的组件能够响应，则分发给组件，否则让app兜底响应
        (eventMap.get(event.tag)?.[event.eventType] ?? uncatchEventHandler)(event);
    &#125;);
&#125;;

export const useFocusableEventHandler = (ref: RefObject&lt;View&gt;, eventObj: TVEventCallbackObj) =&gt; &#123;
    useEffect(() =&gt; &#123;
        const node = findNodeHandle(ref.current);
        node &amp;&amp; eventMap.set(node, eventObj);
        return () =&gt; &#123;
            node &amp;&amp; eventMap.delete(node);
        &#125;;
    &#125;, [ref, eventObj]);
&#125;;
</code></pre>
<p>封装<code>Focusable</code>组件，用来处理页面切换焦点的恢复和封装独立的事件处理逻辑</p>
<pre><code class="tsx">import React, &#123; useEffect, useRef &#125; from &#39;react&#39;;
import &#123; StyleProp, TouchableOpacity, TouchableOpacityProps, ViewStyle, LayoutAnimation &#125; from &#39;react-native&#39;;
import EStyleSheet from &#39;react-native-extended-stylesheet&#39;;
import &#123; useNavigation &#125; from &#39;@react-navigation/native&#39;;
import &#123; action &#125; from &#39;mobx&#39;;
import &#123; observer, useLocalStore &#125; from &#39;mobx-react&#39;;
import &#123; TVEvent, useFocusableEventHandler &#125; from &#39;./useEventHandler&#39;;

export interface FocusableProps extends TouchableOpacityProps &#123;
    scale?: number;
    anim?: boolean;
    hasTVPreferredFocus?: boolean;
    styleFocused?: StyleProp&lt;ViewStyle&gt;;
    // TV发送到当前组件的事件回调，如果未实现对应实现，则默认app.tsx兜底响应，默认不需要实现
    onUp?: (event: TVEvent) =&gt; void;
    onDown?: (event: TVEvent) =&gt; void;
    onLeft?: (event: TVEvent) =&gt; void;
    onRight?: (event: TVEvent) =&gt; void;
    onMenu?: (event: TVEvent) =&gt; void;
&#125;

export default observer((&#123; children, ...props &#125;: FocusableProps) =&gt; &#123;
    const navigation = useNavigation();
    const touchableRef = useRef&lt;TouchableOpacity&gt;(null);

    // 为解决useFocusEffect依赖问题，此处改用store实现
    const store = useLocalStore(() =&gt; (&#123;
        focus: false,
        preferredFocus: props.hasTVPreferredFocus,
        updateFocus: action((focus: boolean) =&gt; &#123;
            store.focus = focus;
        &#125;),
        updatePreferredFocus: action((preferredFocus: boolean) =&gt; &#123;
            store.preferredFocus = preferredFocus;
        &#125;),
    &#125;));

    // 处理焦点恢复逻辑
    useEffect(() =&gt; &#123;
        let focus = false;
        let timer: NodeJS.Timeout;
        const resetPreferredFocus = (preferredFocus: boolean) =&gt; &#123;
            timer &amp;&amp; clearTimeout(timer);
            timer = setTimeout(() =&gt; store.updatePreferredFocus(preferredFocus), 60);
        &#125;;
        const listeners = [
            navigation.addListener(&#39;blur&#39;, () =&gt; &#123;
                // 页面失焦时，记录当前组件焦点状态，并重置preferredFocus状态
                focus = store.focus;
                focus &amp;&amp; resetPreferredFocus(false);
            &#125;),
            navigation.addListener(&#39;focus&#39;, () =&gt; &#123;
                // 再次聚焦时，如果原来是聚焦状态，则通过preferredFocus恢复焦点
                focus &amp;&amp; resetPreferredFocus(true);
            &#125;),
        ];
        return () =&gt; &#123;
            timer &amp;&amp; clearTimeout(timer);
            listeners.forEach(cancel =&gt; cancel());
        &#125;;
    &#125;, [store, navigation]);

    // 处理分发到当前组件的事件回调
    useFocusableEventHandler(touchableRef, &#123;
        // 如果还需要处理其他事件，在此扩展实现...
        up: props.onUp,
        down: props.onDown,
        left: props.onLeft,
        right: props.onRight,
        menu: props.onMenu,
    &#125;);

    return (
        &lt;TouchableOpacity
            &#123;...props&#125;
            ref=&#123;touchableRef&#125;
            activeOpacity=&#123;props.activeOpacity ?? 1.0&#125;
            hasTVPreferredFocus=&#123;store.preferredFocus&#125;
            style=&#123;[
                styles.unFocused,
                props.style,
                store.focus &amp;&amp; [styles.styleFocused, props.styleFocused],
                store.focus &amp;&amp; props.scale &amp;&amp; &#123; transform: [&#123; scale: props.scale &#125;] &#125;,
            ]&#125;
            onFocus=&#123;event =&gt; &#123;
                // 执行动画
                if (props.anim) &#123;
                    LayoutAnimation.spring();
                &#125;
                store.updateFocus(true);
                props.onFocus?.(event);
            &#125;&#125;
            onBlur=&#123;event =&gt; &#123;
                store.updateFocus(false);
                props.onBlur?.(event);
            &#125;&#125;
        &gt;
            &#123;typeof children === &#39;function&#39; ? children(store.focus) : children&#125;
        &lt;/TouchableOpacity&gt;
    );
&#125;);

const styles = EStyleSheet.create(&#123;
    unFocused: &#123;
        borderWidth: 2,
        borderColor: &#39;transparent&#39;,
    &#125;,
    styleFocused: &#123;
        borderWidth: 2,
        borderColor: &#39;#FFFFFF&#39;,
        borderRadius: 5,
        backgroundColor: &#39;#FFFFFF20&#39;,
    &#125;,
&#125;);
</code></pre>
<p>最后在App组件，处理全局的未响应的事件</p>
<pre><code class="tsx">// 遥控器事件
useAppEventHandler((&#123; eventType &#125;) =&gt; &#123;
    if ([&#39;up&#39;, &#39;menu&#39;].includes(eventType)) &#123;
        // do something 。。。
    &#125;
&#125;);
</code></pre>
<h3 id="webview坑点"><a href="#webview坑点" class="headerlink" title="webview坑点"></a>webview坑点</h3><p>因为应用内有大量的图表，我们使用了<code>Webview组件</code>，后来发现，焦点会自动进入到webview内部的HTML元素，导致焦点不可控；网上热心网友提供的方案都不太可靠，基本都是通过<code>Activity.onKeyDown</code>拦截事件，并不太优雅，看过<code>ViewGroup</code>代码后发现很简单，元素是否可以聚焦是通过<code>focuseable</code>属性控制的，RN层的<code>View</code>组件默认实现了<code>focuseable</code>属性，但是比较遗憾的是<code>Webview.props</code>虽然也有该接口，但是原生侧并未实现，我们通过<code>postinstall</code>钩子函数给<code>Webview打个补丁即可</code>，代码如下：</p>
<pre><code class="javascript">const fs = require(&#39;fs&#39;);

const webViewManagerFilePath = &#39;node_modules/react-native-webview/android/src/main/java/com/reactnativecommunity/webview/RNCWebViewManager.java&#39;;

fs.writeFileSync(
    webViewManagerFilePath,
    fs
        .readFileSync(webViewManagerFilePath)
        .toString()
        .replace(
            `
  @ReactProp(name = &quot;focusable&quot;)
  public void setFocusEnabled(WebView view, boolean enabled) &#123;
    view.setFocusable(enabled);
  &#125;
`,
            &#39;&#39;,
        )
        .replace(
            /@ReactProp\(name = &quot;javaScriptEnabled&quot;\).*/,
            `
  @ReactProp(name = &quot;focusable&quot;)
  public void setFocusEnabled(WebView view, boolean enabled) &#123;
    view.setFocusable(enabled);
  &#125;

  @ReactProp(name = &quot;javaScriptEnabled&quot;)\
`,
        ),
);
</code></pre>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://developer.android.google.cn/training/tv/start/start?hl=zh-cn">https://developer.android.google.cn/training/tv/start/start?hl=zh-cn</a></li>
<li><a target="_blank" rel="noopener" href="https://reactnative.dev/docs/building-for-tv">https://reactnative.dev/docs/building-for-tv</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_36330148/article/details/117280419">https://blog.csdn.net/weixin_36330148/article/details/117280419</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/QKLee/article/details/52053447">https://blog.csdn.net/QKLee/article/details/52053447</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41898048/article/details/124405239">https://blog.csdn.net/qq_41898048/article/details/124405239</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43316280/article/details/126578324">https://blog.csdn.net/qq_43316280/article/details/126578324</a></li>
</ol>

        <!-- 分类文章 -->
        
      </div>
      <div class="post-content-inner-space">
        
          <div class="space-toc-main animate__animated  animate__fadeInUp">
            <ol class="space-toc"><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88"><span class="space-toc-text">技术方案</span></a><ol class="space-toc-child"><li class="space-toc-item space-toc-level-3"><a class="space-toc-link" href="#%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B"><span class="space-toc-text">技术选型</span></a></li><li class="space-toc-item space-toc-level-3"><a class="space-toc-link" href="#%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B"><span class="space-toc-text">技术演进</span></a></li></ol></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E5%B7%A5%E7%A8%8B%E5%8C%96%E9%85%8D%E7%BD%AE"><span class="space-toc-text">工程化配置</span></a><ol class="space-toc-child"><li class="space-toc-item space-toc-level-3"><a class="space-toc-link" href="#Android%E9%85%8D%E7%BD%AE"><span class="space-toc-text">Android配置</span></a></li><li class="space-toc-item space-toc-level-3"><a class="space-toc-link" href="#RN%E9%85%8D%E7%BD%AE"><span class="space-toc-text">RN配置</span></a></li></ol></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E9%81%A5%E6%8E%A7%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91"><span class="space-toc-text">遥控事件分发</span></a><ol class="space-toc-child"><li class="space-toc-item space-toc-level-3"><a class="space-toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E9%80%BB%E8%BE%91"><span class="space-toc-text">事件分发逻辑</span></a></li><li class="space-toc-item space-toc-level-3"><a class="space-toc-link" href="#%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85"><span class="space-toc-text">组件封装</span></a></li><li class="space-toc-item space-toc-level-3"><a class="space-toc-link" href="#webview%E5%9D%91%E7%82%B9"><span class="space-toc-text">webview坑点</span></a></li></ol></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="space-toc-text">参考资料</span></a></li></ol>
           </div>
        
      </div>
   </div>
    <!-- 评论 -->
    
  </div>
</article>
  </div>
</div>



<!-- 如果是home模式的话，不在首页就显示footer，如果不是home模式的话 所有都显示footer -->

  <div class="footer-outer animate__animated  animate__fadeInUp">
    <div class="footer-inner">
    <div class="footer-text">
    <p>Power by <a target="_blank" rel="noopener" href="http://hexo.io/">Hexo</a> Theme by <a target="_blank" rel="noopener" href="https://github.com/FuShaoLei/hexo-theme-white">White</a></p>

    </div>
    <div class="footer-contact">
    <ul class="footer-ul">
        
        <li class="footer-li">
            <a href="https://github.com/John251314" target="_blank">
                <i class="ri-github-line"></i>
            </a>
        </li>
        
        <li class="footer-li">
            <a href="mailto:lijihui2513114@163.com" target="_blank">
                <i class="ri-mail-line"></i>
            </a>
        </li>
        
        <li class="footer-li">
            <a href="tel:13260885032" target="_blank">
                <i class="ri-phone-line"></i>
            </a>
        </li>
        
    </ul>
    </div>
    </div>
</div>






<script src="/js/white.js"></script>



    
      
<script src="/js/highlight.min.js"></script>

      <script>hljs.initHighlightingOnLoad();</script>
    

</body>
</html>
